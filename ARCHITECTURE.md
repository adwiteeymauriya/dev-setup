# Architecture Overview

## Pure NixOS Approach

This configuration uses **100% declarative NixOS** with no bash scripts. Everything is defined in Nix configuration files.

## File Structure

```
.
├── flake.nix                    # Entry point - defines inputs & outputs
├── configuration.nix            # System-level configuration
├── home.nix                     # User-level configuration (home-manager)
├── hardware-configuration.nix   # Hardware-specific settings
│
├── README.md                    # Main documentation
├── QUICKSTART.md               # Quick setup guide
├── MIGRATION.md                # Bash → NixOS migration guide
├── CHEATSHEET.md               # Common commands reference
├── ARCHITECTURE.md             # This file
│
└── setup_dev.sh                # [Legacy] Old bash script (for reference)
```

## Configuration Layers

### 1. Flake (flake.nix)

Defines the system as a Nix flake with:
- **Inputs**: nixpkgs, home-manager
- **Outputs**: NixOS configuration named "devserver"

```nix
outputs = { self, nixpkgs, home-manager, ... }: {
  nixosConfigurations.devserver = ...
};
```

### 2. System Configuration (configuration.nix)

Handles **root-level** system configuration:

#### Filesystem Management
```nix
fileSystems."/home" = {
  device = "/dev/disk/by-id/scsi-0HC_Volume_103912881";
  fsType = "ext4";
};

fileSystems."/nix" = {
  device = "/home/qwe/nix";
  fsType = "none";
  options = [ "bind" ];
};
```

**Why this works without bash:**
- NixOS automatically creates mount points
- NixOS handles mounting at boot
- Bind mounts are native to NixOS
- No manual `/etc/fstab` editing needed

#### User Management
```nix
users.users.qwe = {
  isNormalUser = true;
  uid = 1000;
  shell = pkgs.zsh;
  extraGroups = [ "wheel" "docker" ];
};
```

**Why this works without bash:**
- NixOS creates users declaratively
- UID/GID are guaranteed
- Groups are assigned automatically
- Home directory is created with correct ownership

#### Services
```nix
services.openssh.enable = true;
virtualisation.docker.enable = true;
```

**Why this works without bash:**
- NixOS manages systemd services
- Dependencies are handled automatically
- Services start/stop with system

### 3. User Configuration (home.nix)

Handles **user-level** configuration via home-manager:

#### Package Installation
```nix
home.packages = with pkgs; [
  devbox
  nodejs_22
  uv
];
```

**Why this works without curl | bash:**
- All packages from nixpkgs (reproducible)
- Binary cache for fast downloads
- Dependency resolution automatic
- No PATH manipulation needed

#### Shell Configuration
```nix
programs.zsh = {
  enable = true;
  enableCompletion = true;
  oh-my-zsh.enable = true;
};
```

**Why this works without editing .zshrc:**
- home-manager generates config files
- Declarative shell customization
- No manual file editing
- Idempotent (safe to reapply)

### 4. Hardware Configuration (hardware-configuration.nix)

Auto-generated per machine:
```nix
boot.initrd.availableKernelModules = [ "virtio_pci" "virtio_scsi" ];
```

**Generated by**: `nixos-generate-config`

## Comparison: Bash vs NixOS

### Volume Mounting

**Bash Script:**
```bash
mkdir -p "$HOME_DIR"
sed -i "\|$DEVICE|d" /etc/fstab
echo "$DEVICE $HOME_DIR ext4 discard,defaults 0 2" >> /etc/fstab
mount "$HOME_DIR"
```

**NixOS:**
```nix
fileSystems."/home" = {
  device = "/dev/disk/by-id/scsi-0HC_Volume_103912881";
  fsType = "ext4";
};
```

✅ No manual file editing
✅ Automatically mounted at boot
✅ Atomic (all-or-nothing)

### User Creation

**Bash Script:**
```bash
useradd -m -d "$HOME_DIR" -s "$ZSH_BIN" -u 1000 -g 1000 qwe
chown -R qwe:qwe "$HOME_DIR"
echo "qwe ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/qwe
```

**NixOS:**
```nix
users.users.qwe = {
  isNormalUser = true;
  uid = 1000;
  shell = pkgs.zsh;
  extraGroups = [ "wheel" ];
};
security.sudo.wheelNeedsPassword = false;
```

✅ Declarative user definition
✅ Automatic home directory creation
✅ Correct permissions automatically
✅ Idempotent

### Package Installation

**Bash Script:**
```bash
sudo -u qwe bash <<'EOF'
  curl -L https://nixos.org/nix/install | sh
  curl -fsSL https://get.jetpack.io/devbox | bash
  curl -LsSf https://astral.sh/uv/install.sh | sh
EOF
```

**NixOS:**
```nix
home.packages = [ pkgs.devbox pkgs.uv ];
```

✅ No curl | bash
✅ Reproducible versions
✅ Dependency management
✅ Easy rollback

### Docker Installation

**Bash Script:**
```bash
curl -fsSL https://get.docker.com -o /tmp/get-docker.sh
sh /tmp/get-docker.sh
usermod -aG docker qwe
```

**NixOS:**
```nix
virtualisation.docker.enable = true;
users.users.qwe.extraGroups = [ "docker" ];
```

✅ Systemd service managed
✅ User groups automatic
✅ Starts at boot

## The Only Manual Step

**Formatting the volume** (one-time):
```bash
mkfs.ext4 /dev/disk/by-id/scsi-0HC_Volume_103912881
```

**Why manual?**
- Destructive operation (data loss)
- Should be explicit and intentional
- Only needed once per volume
- Not part of system state

**Everything else** is handled by NixOS configuration.

## System Lifecycle

### Initial Setup
```
1. Install NixOS
2. Format volume (manual, one-time)
3. Clone config to /etc/nixos
4. nixos-rebuild switch --flake .#devserver
   ↓
   NixOS handles everything:
   - Mount filesystems
   - Create users
   - Install packages
   - Start services
```

### Updates
```
1. Edit configuration.nix or home.nix
2. nixos-rebuild switch --flake .#devserver
   ↓
   NixOS calculates diff and applies changes atomically
```

### Rollback
```
1. Something broke
2. nixos-rebuild switch --rollback
   ↓
   System instantly reverts to previous working state
```

## State Management

### Persistent State (survives rebuilds)
- `/home/qwe` - User data on external volume
- `/nix` - Nix store (bind mounted to volume)

### Ephemeral State (rebuilt each time)
- `/` - Root filesystem
- System configuration
- User environment configuration

### Configuration State (version controlled)
- All `.nix` files in `/etc/nixos`
- Tracked in Git
- Reproducible across machines

## Benefits of Pure NixOS

### 1. No Imperative Steps
- No `sudo -u` gymnastics
- No checking "if installed"
- No manual PATH management
- No state markers (`.dev_tools_installed`)

### 2. Guaranteed Idempotency
- Can apply configuration multiple times
- Same result every time
- No "already installed" logic needed

### 3. Atomic Updates
- Either succeeds completely or fails
- No partial states
- Easy rollback

### 4. Reproducibility
- Same configuration = same system
- Works on any NixOS machine
- No environmental differences

### 5. Self-Documenting
- Configuration IS documentation
- Easy to see what's installed
- Clear system state

## Security

### No curl | bash
All packages come from:
- nixpkgs (reviewed, reproducible)
- Binary cache (pre-built, signed)
- Source builds (deterministic)

### Declarative Permissions
```nix
users.users.qwe.openssh.authorizedKeys.keys = [ ... ];
```
- No manual key copying
- Permissions set correctly
- Survives rebuilds

### Minimal Attack Surface
- Only necessary services enabled
- Firewall enabled by default
- Updates are atomic and rollback-able

## Debugging

### Check what will change
```bash
nixos-rebuild dry-run --flake .#devserver
```

### Build without switching
```bash
nixos-rebuild build --flake .#devserver
```

### Test in VM
```bash
nix run nixpkgs#nixos-rebuild -- build-vm --flake .#devserver
./result/bin/run-nixos-vm
```

### Trace errors
```bash
nixos-rebuild switch --flake .#devserver --show-trace
```

## Conclusion

This is a **pure NixOS** setup with:
- ✅ Zero bash scripts (except legacy reference)
- ✅ 100% declarative configuration
- ✅ Complete reproducibility
- ✅ Atomic updates & rollback
- ✅ Self-documenting system

The only non-Nix operation is formatting the volume initially, which is intentionally manual for safety.

Everything else is handled by NixOS configuration files, making it:
- More reliable
- Easier to maintain
- Fully reproducible
- Version controlled
- Testable before deployment
